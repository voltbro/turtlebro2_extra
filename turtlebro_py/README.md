# Пакет предназначен для работы с роботом Turtlebro напрямую из Python
Данный пакет представляет из себя аналог стандартного модуля `turtle`, который используется при обучении Python для школьников. Аналогично с модулем `turtle`, в котором черепашка выполняет простые команды и рисует геометрические фигуры на экране, с помощью данного пакета, учашиеся смогут управлять роботом TurtleBro (www.trurtlebro.ru), при помощи простых команд, описанных ниже. Данный пакет предполагается использовать для предварительного обучения Python и основам робототехники перед погружением в изучение Robot Operation System (www.ros.org). Для изучения ROS, предполагается использовать того-же робота TurtleBro, но уже в рамках образовательного курса "Введение в ROS" (https://voltbro.gitbook.io/turtlebro_py)  

## Установка пакета

Пакет входит в сборку метапакета `turtlebro_extra` и устанавливается автоматически при установке этого пакета. Для установки метапакета на роботе выполните команды:

```
mkdir -p ~/turtlebro_ws/src
cd ~/turtlebro_ws/src
git clone https://github.com/voltbro/turtlebro_extra
cd ..
colcon build --packages-select turtlebro_py
source install/setup.bash
```
После установки пакета загрузите на Arduino Due прошивку из каталога `ino/turtlebro_py/turtlebro_py.ino`. Прошивка переведена на библиотеку `micro_ros_arduino`, использует аппаратный порт `Serial1` и механизм переподключения по примеру `microros_reconnection` (https://github.com/voltbro/turtlebro2-examples/tree/master/arduino/microros_reconnection). Пошаговые инструкции по настройке Arduino и micro-ROS доступны в документации: https://ros2.turtlebro.ru/rabota-s-arduino-due/10-arduino.html и https://ros2.turtlebro.ru/rabota-s-arduino-due/20-microros.html.

### Аппаратные топики Arduino micro-ROS

- `/buttons` (`std_msgs/Int16`) — события от кнопок, публикуется номер пина при переходе в активное состояние. Пользовательские кнопки подключены к D28 и D29.
- `/buttons/d28` и `/buttons/d29` (`std_msgs/Bool`) — состояние каждой кнопки (true/false) с программной защитой от дребезга.
- `/switches/d16` и `/switches/d15` (`std_msgs/Bool`) — состояние тумблеров на пинах D16 и D15.
- `/arduino/servos` (`std_msgs/Int16MultiArray`) — управление сервоприводами/колёсными сервами на пинах D2–D7. Сообщение состоит из пар `[пин, угол]`, где `пин` — номер цифрового выхода (2…7), а `угол` задаётся в градусах от `0` до `180` (`90` — нейтральное положение ~1500 мкс). За одну публикацию можно отправить несколько пар.
- `/thermovisor` (`std_msgs/Float32MultiArray`) — 64 float-значения с тепловизора AMG88xx.

Поддержка RGB-ленты удалена из скетча, поэтому топик `/py_leds` остаётся только для обратной совместимости с другими узлами.


### Использование библиотеки команд

Для работы с роботом импортируйте класс `TurtleBro` из библиотеки `turtlebro_py` в Python, и проинициализируйте этот класс с присвоением ему какого-то имени, например вот так:
``` 
from turtlebro_py import TurtleBro
tb = TurtleBro()
```

Для движения робота вперед используйте команду `forward`, указав в качестве аргумента количество метров на которое вы хотите переместить робота:

```
tb.forward(0.7)  #робот проедет вперед 0.7 метра
```

Для движения робота назад используйте команду `backward`, указав в качестве аргумента количество метров на которое вы хотите переместить робота:

```
tb.backward(0.3)  #робот проедет назад 0.3 метра
```

Для поворота робота направо, (т.е. против часовой стрелки) используйте команду `right`, указав в качестве аргумента количество градусов на которое вы хотите повернуть робота
```
tb.right(90)  #робот повернется против часовой стрелки на 90 градусов
```

Для поворота робота налево, (т.е. по часовой стрелке) используйте команду `left`, указав в качестве аргумента количество градусов на которое вы хотите повернуть робота
```
tb.left(90)  #робот повернется по часовой стрелке на 90 градусов
```

Универсальный поворот доступен через `turn`: положительный угол поворачивает влево, отрицательный вправо. Можно задавать углы больше `360`.
```
tb.turn(450)   # поворот влево на 450 градусов
tb.turn(-180)  # поворот вправо на 180 градусов
```

Для того чтобы робот поехал на точку с координатами `x, y` (в метрах), используйте команду goto, указав в качестве аргументов `x` и `y`:
```
tb.goto(0.5, 1)  #робот поедет на точку с координатами x = 0.5 м, y = 1 м.
```
При расчете координат используется правило правой руки.
Команды движения `forward`, `backward`, `left`, `right`, `turn` и `goto` возвращают `True` при успешном выполнении и `False` при ошибке.

Для получения текущей позы `x, y, theta` (в метрах и градусах) в системе отсчета, связанной с точкой старта, используйте переменную `pose`:
```
x, y, theta = tb.pose  # текущие координаты и угол робота
```
При расчете координат используется правило правой руки.

### Работа с тепловизором

Функциональность тепловизора вынесена из класса `TurtleBro` в отдельный помощник `ThermalImages`.  
Используйте его, чтобы подписаться на `Float32MultiArray` из `/thermovisor` и получать те же данные, что ранее приходили через `tb.thermo_pixels`:

```
from turtlebro_py import ThermalImages

ti = ThermalImages(wait_for_first_frame=True)
pixels = ti.thermo_pixels  # или ti.pixels

# ... используйте pixels ...

```

Через аргументы конструктора можно выбрать имя топика (`topic`), размер очереди (`queue_size`) и указать, нужно ли автоматически дождаться первого кадра (`wait_for_first_frame`, `wait_timeout`). При необходимости вызовите `wait_for_frame(timeout=5.0)`, чтобы синхронно дождаться нового сообщения от тепловизора.

Для перевода робота в режим ожидания (задержка между действиями), используйте команду `wait`, передавая в качестве аргумента время в секундах:
```
tb.wait(2) #робот сделает задержку между действиями в 2 секунды
```

Для настройки скорости робота используйте команду `speed`, передавая в качестве аргумента одну из желаемых скоростей: "fastest":0.17, "fast":0.12, "normal":0.09, "slow":0.04, "slowest":0.01
```
tb.speed("normal") #робот установит линейную скорость - 0.09 м/с
```

Для включения светодиодов на роботе используйте команду `color`, указав в качестве аргумента цвет светодиодов (red, green, yellow, blue, white, off):

```
tb.color("green")  #робот зажжет зеленые светодиоды
tb.color("red")  #робот зажжет красные светодиоды
tb.color("off")  #робот выключит светодиоды
```

На плате v2 светодиодная лента также доступна напрямую через ROS-топики `/backlight/all` и `/backlight/array`.  
Для работы с ними в Python добавлены методы:

```
tb.backlight_all("blue")              # отправить цвет по всему стеку
tb.backlight_all((1.0, 0.2, 0.0))     # RGB, альфа = 1.0 по умолчанию

tb.backlight_array(["red"] * 24)      # передать массив цветов по индексам
tb.backlight_array({0: "white", 5: (0, 0, 1, 0.5)}, fill="off")
```

`backlight_array` принимает готовый `ColorRGBAArray`, список/кортеж цветов или словарь вида `{индекс: цвет}`; цвета можно задавать именем (red, green, …), последовательностью из 3/4 чисел (RGB/RGBA) или сообщением `std_msgs/ColorRGBA`.  
Исторический метод `color` теперь сохраняет обратную совместимость и дополнительно публикует тот же цвет в `/backlight/all`.

Для определения расстояния до препятствия перед роботом используйте команду `distance`,
```
dist = tb.distance() #Расстояние до препятствия "перед" роботом.
```
Для определения расстояния до препятствия находящегося на определенном углу, используйте команду `distance` с аргументом равным градусу по которому вы хотите получить расстояние до препятствия:
```
dist = tb.distance(90) #Расстояние до препятствия "слева" от робота.
```
Опционально, вы можете указать аргумент = 360 для команды, тогда она вернет массив из 360 точек (по одной на градус) расстояний до препятствий вокруг робота.
```
ranges = []
ranges = tb.distance(360)
```

Для получения изображения с камеры робота используйте команду `save_photo`:
```
tb.save_photo() #Робот сохранит изображение в файл /home/pi/robophoto.jpg.
```
Опционально, вы можете указать имя файла в который надо сохранить изображение и тогда робот сохранит фото в файл /home/pi/ИМЯ_ФАЙЛА.jpg

```
tb.save_photo("ИМЯ_ФАЙЛА")
```

Для получения изображения с камеры робота в виде массива ```numpy``` используйте функцию tb.get_photo():
```
ph = tb.get_photo() #Робот сохранит изображение в виде массива numpy в переменную ph
```

Для записи звука с камеры робота используйте команду `record`:
```
tb.record() #Робот сохранит 3 секунды записанного звука в файл /home/pi/turtlebro_sound.wav
```
Опционально вы можете указать длительность записи и базовое имя выходного файла:

```
tb.record(10, "mysound") #Робот будет записывать звук 10 секунд, и затем сохранит это в файл /home/pi/mysound.wav
```

Для воспроизведения WAV-файлов из каталога `/home/pi` используйте команду `play`:
```
tb.play("mysound.wav") # Робот начнёт проигрывать файл /home/pi/mysound.wav в фоновом режиме
```
Если нужно дождаться завершения проигрывания или выбрать другое ALSA-устройство, воспользуйтесь именованными аргументами:
```
tb.play("alarm", blocking=True, device="hw:1,0")
```

Для воспроизведения голосом какого-то текста из динамиков робота используйте команду `say`:
```
tb.say("Однажды в студёную зимнюю пору...") #Робот воспроизведет фрагмент стихотворения Н.А.Некрасова
```

Под капотом `say` отправляет Action `text_to_speech` в пакет `turtlebro_actions`, который озвучивает текст через RHVoice (speech-dispatcher). Убедитесь, что запущен лаунч `ros2 launch turtlebro_actions action_servers.launch.py`, установлены `python3-speechd`, `speech-dispatcher` и выбран голос RHVoice (например, `Vsevolod`).

Через именованные аргументы можно выбирать голос, темп, язык и режим пунктуации:

```
tb.say(
    "Проверка синтеза речи",
    voice="Vsevolod",
    rate=20,
    language="ru",
    punctuation_mode="SOME",
)
```

`voice` — имя голоса из `speechd.list_synthesis_voices()`, `rate` — относительная скорость (0 оставляет настройку по умолчанию), `language` — код языка (например, `ru` или `en`), `punctuation_mode` — `NONE`, `SOME` или `ALL`.


Для вызова написанной вами функции при нажатии на кнопку D28 используйте команду `call`:
```
def myfunc():
    print("Привет из моей функции")

tb.call(myfunc) #при нажатии на кнопку D28, вызовется функция myfunc и выведет "Привет из моей функции"
```
Опционально, вы можете привязать по одной функции на каждую доступную кнопку, передав требуемый номер пина (`28` или `29`) в параметр `button`. Состояние тумблеров на D16 и D15 можно читать напрямую через топики `/switches/d16` и `/switches/d15`.

```
def myfunc1():
    print("Привет из моей функции 1")

def myfunc2():
    print("Привет из моей функции 2")

tb.call(myfunc1, 28) #при нажатии на кнопку D28, вызовется функция myfunc1
tb.call(myfunc2, 29) #при нажатии на кнопку D29, вызовется функция myfunc2
```

Пример кода для езды по квадрату длиной 20 см, со скоростью 0.1 м/с и смены цвета диодов на каждой стороне квадрата:

```
from turtlebro_py import TurtleBro
tb = TurtleBro()

tb.color("green")
tb.forward(0.2)
tb.right(90)

tb.color("red")
tb.forward(0.2)
tb.right(90)

tb.color("yellow")
tb.forward(0.2)
tb.right(90)

tb.color("blue")
tb.forward(0.2)
tb.right(90)
```

### Использование TurtleBroNav
Для ознакомления с базовой функциональностью автономной навигации в ROS можно использовать класс TurtleBroNav из данной библиотеки. Однако для того, чтобы использовать автономную навигацию, ее надо предварительно включить !на роботе! командой `ros2 launch turtlebro_navigation turtlebro_slam_navigation.launch.py`
```
from turtlebro_py import TurtleBroNav
tn = TurtleBroNav()
```

Основная команда, которая может использоваться для перемещения робота при помощи автономной навигации это `goto`, для того чтобы робот поехал на точку с координатами `x, y` (в метрах), укажите в качестве аргументов `x` и `y`:
```
tn.goto(0.5, 1)  #робот поедет на точку с координатами x = 0.5 м, y = 1 м.
```
При расчете координат используется правило правой руки. Обратите внимание, что теперь робот будет ехать по навигационным целям, при этом он, например, будет объезжать препятствия возникающие у него на пути.
Кроме команды `goto`, вы можете использовать остальные команды передвижения (`forward, backward, left, right`) и все остальные команды типа `photo` или `say`
